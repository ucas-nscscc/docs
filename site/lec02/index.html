
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.1, mkdocs-material-8.5.7">
    
    
      
        <title>Lec 02 - git 协作，SOC 与裸机程序 - UCAS NSCSCC</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.20d9efc8.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lec-02-git-soc" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="UCAS NSCSCC" class="md-header__button md-logo" aria-label="UCAS NSCSCC" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            UCAS NSCSCC
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Lec 02 - git 协作，SOC 与裸机程序
            
          </span>
        </div>
      </div>
    </div>
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="UCAS NSCSCC" class="md-nav__button md-logo" aria-label="UCAS NSCSCC" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    UCAS NSCSCC
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        NSCSCC 2023
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec01/" class="md-nav__link">
        Lec 01 - “龙芯杯”大赛介绍
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Lec 02 - git 协作，SOC 与裸机程序
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Lec 02 - git 协作，SOC 与裸机程序
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#git" class="md-nav__link">
    git 协作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    总线接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#soc" class="md-nav__link">
    SOC 结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    控制外设
  </a>
  
    <nav class="md-nav" aria-label="控制外设">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    直接读写外设
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    外部计数器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    扩展其他外设
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    裸机程序
  </a>
  
    <nav class="md-nav" aria-label="裸机程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    第一入口：汇编语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    第二入口：C 语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    链接脚本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coe" class="md-nav__link">
    二进制文件与 COE 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    上板测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    参考资料
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          杂项
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="杂项" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          杂项
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../misc/linux/" class="md-nav__link">
        Linux 操作系统杂谈
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../misc/lec02/" class="md-nav__link">
        对于 lec 02 的一些补充
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../misc/vivado/" class="md-nav__link">
        在 Linux 上使用 Vivado 可能遇到的问题
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#git" class="md-nav__link">
    git 协作
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    总线接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#soc" class="md-nav__link">
    SOC 结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    控制外设
  </a>
  
    <nav class="md-nav" aria-label="控制外设">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    直接读写外设
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    外部计数器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    扩展其他外设
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    裸机程序
  </a>
  
    <nav class="md-nav" aria-label="裸机程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    第一入口：汇编语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    第二入口：C 语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    链接脚本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coe" class="md-nav__link">
    二进制文件与 COE 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    上板测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    参考资料
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="lec-02-git-soc">lec 02 - git 协作，SOC 与裸机程序</h1>
<h2 id="git">git 协作</h2>
<p>在过去的课程中，大家使用 git 往往是进行个人项目的版本管理，很少涉及多人协作的场景。而对于“龙芯杯”比赛而言，则需要小组内成员合理分工，并使用 git 进行协作开发。使用 git 的诀窍在于脑海里时刻有一张有向图：每一个结点表示一次 commit，每一个边表示两次 commit 之间的变化。</p>
<p>在这张图里，所有结点的公共祖先都是第一次 commit：</p>
<div class="highlight"><pre><span></span><code>$ mkdir my-prj <span class="o">&amp;&amp;</span> <span class="nb">cd</span> my-prj
$ touch README.md
$ git init <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&quot;init commit&quot;</span>
Initialized empty Git repository <span class="k">in</span> /home/haooops/my-prj/.git/
<span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> 2d99435<span class="o">]</span> init commit
 <span class="m">1</span> file changed, <span class="m">0</span> insertions<span class="o">(</span>+<span class="o">)</span>, <span class="m">0</span> deletions<span class="o">(</span>-<span class="o">)</span>
 create mode <span class="m">100644</span> README.md

<span class="c1">#    HEAD(master)</span>
<span class="c1">#      |</span>
<span class="c1">#      +</span>
<span class="c1"># init commit</span>
<span class="c1">#</span>
<span class="c1"># 通过 git commit 我们创建了第一个 commit 结点，一个指针</span>
<span class="c1"># HEAD 指向我们目前所处的分支 master。</span>
</code></pre></div>
<p>对 <code>README.md</code> 进行修改：</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;# README&quot;</span> &gt;&gt; README.md
$ git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&quot;update README.md&quot;</span>
<span class="o">[</span>master 0493f9d<span class="o">]</span> update README.md
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>

<span class="c1">#                HEAD(master)</span>
<span class="c1">#                  |</span>
<span class="c1">#      +-----&gt;-----+</span>
<span class="c1">#         &quot;update README.md&quot;</span>
<span class="c1">#</span>
<span class="c1"># 上图中用一条有向边由第一次 commit 指向第二次 commit，</span>
<span class="c1"># 表示第二次 commit 是在第一次的基础上变化而来的。</span>
</code></pre></div>
<p>创建并切换一个新的分支：</p>
<div class="highlight"><pre><span></span><code>$ git checkout -b new
Switched to a new branch <span class="s1">&#39;new&#39;</span>

<span class="c1">#             master HEAD(new)</span>
<span class="c1">#                  |/</span>
<span class="c1">#      +-----&gt;-----+</span>
<span class="c1">#         &quot;update README.md&quot;</span>
<span class="c1">#</span>
<span class="c1"># 此时创建分支实际上只是创建了一个指针，指向与 master</span>
<span class="c1"># 相同的 commit 结点。</span>
</code></pre></div>
<p>在新的分支上对 <code>README.md</code> 进行修改：</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;## chapter 1&quot;</span> &gt;&gt; README.md
$ git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&quot;update README.md&quot;</span>
<span class="o">[</span>new 91a9767<span class="o">]</span> update README.md
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>

<span class="c1">#                master       HEAD(new)</span>
<span class="c1">#                  |           |</span>
<span class="c1">#      +-----&gt;-----+-----&gt;-----+</span>
<span class="c1">#                   update README.md</span>
<span class="c1">#</span>
<span class="c1"># 当我们在 new 上进行修改时，master 指针没有变化。</span>
</code></pre></div>
<p>回到 <code>master</code> 后创建并切换一个新的分支：</p>
<div class="highlight"><pre><span></span><code>$ git checkout master <span class="o">&amp;&amp;</span> git checkout -b bee
Switched to branch <span class="s1">&#39;master&#39;</span>
Switched to a new branch <span class="s1">&#39;bee&#39;</span>

<span class="c1">#             master HEAD(bee)  new</span>
<span class="c1">#                  |/           /</span>
<span class="c1">#      +-----&gt;-----+-----&gt;-----+</span>
<span class="c1">#                   update README.md</span>
<span class="c1">#</span>
<span class="c1"># 创建新分支 bee 的效果与之前从 master 上创建 new 相同。</span>
</code></pre></div>
<p>在新的分支上对 <code>README.md</code> 进行修改：</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> <span class="s2">&quot;## chapter 2&quot;</span> &gt;&gt; README.md
$ git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&quot;update README.md&quot;</span>
<span class="o">[</span>bee b8a67e1<span class="o">]</span> update README.md
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>

<span class="c1">#               master        new</span>
<span class="c1">#                  |           |</span>
<span class="c1">#      +-----&gt;-----+-----&gt;-----+</span>
<span class="c1">#                  \-----&gt;-----+</span>
<span class="c1">#                              |</span>
<span class="c1">#                           HEAD(bee)</span>
</code></pre></div>
<p>合并 new、bee 两个分支到 new：</p>
<div class="highlight"><pre><span></span><code>$ git checkout new <span class="o">&amp;&amp;</span> git merge bee
Switched to branch <span class="s1">&#39;new&#39;</span>
Auto-merging README.md
CONFLICT <span class="o">(</span>content<span class="o">)</span>: Merge conflict <span class="k">in</span> README.md
Automatic merge failed<span class="p">;</span> fix conflicts and <span class="k">then</span> commit the result.
</code></pre></div>
<p>此时发生了冲突（conflict），git 提示需要进行手动合并，然后再 commit 一次：
<div class="highlight"><pre><span></span><code>$ cat README.md
<span class="c1"># README</span>
<span class="o">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
<span class="c1">## chapter 1</span>
<span class="o">=======</span>
<span class="c1">## chapter 2</span>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; bee

<span class="c1"># git 在冲突文件中将产生冲突的部分标记了出来，其中 === 上面的部分表示目前</span>
<span class="c1"># 所处分支 new 中的内容，而 === 下面的部分表示待 merge 分支 bee 的内容。</span>
</code></pre></div></p>
<p>我们可以直接对产生冲突的文件进行修改。在 vscode 中，提供了默认的插件，可以方便地进行分支合并：</p>
<p><img alt="" src="../img/conflict.png" /></p>
<p>根据需要点击选项，留下需要的内容，然后再进行一次 commit：</p>
<div class="highlight"><pre><span></span><code>$ git add README.md &amp;&amp; git commit -m &quot;merge new and bee&quot;
[new 0c8d026] merge new and bee

#                master                 HEAD(new)
#                  |                       |
#      +-----&gt;-----+-----&gt;-----+-----&gt;-----+
#                  \-----&gt;-----+-----&gt;-----/
#                              |
#                             bee
#
# 
# 将 bee 合并到 new 后，创建了一次新的 commit，并将
# HEAD 指针移动到该 commit。
</code></pre></div>
<p>合并 new 分支到 master：</p>
<div class="highlight"><pre><span></span><code>$ git checkout master &amp;&amp; git merge new
Updating 0493f9d..0c8d026
Fast-forward
 README.md | 2 ++
 1 file changed, 2 insertions(+)

#                             HEAD(master) new
#                                         \|
#      +-----&gt;-----+-----&gt;-----+-----&gt;-----+
#                  \-----&gt;-----+-----&gt;-----/
#                              |
#                             bee
#
# 由于 new 是从 master 上发展过来的，因此 merge
# 操作仅仅是将 master 指针移动到了 new。
</code></pre></div>
<p>合并的规律：
+ 如果两次 commit 代表的结点有连通的路径，则合并时仅改变指针
+ 如果没有，则会创建一个新的结点，并可能产生冲突</p>
<h2 id="_1">总线接口</h2>
<blockquote>
<p>“在大多数真实的计算机系统中，CPU 通过总线与系统中的内存、外设进行交互。没有总线，CPU 就是个‘光杆司令’，什么工作也做不了。总线接口可以自行定义，也可以遵照工业的标准。显然，遵照工业界的标准有助于与大量第三方的 IP 进行集成。” — <em>《CPU 设计实战》</em></p>
</blockquote>
<p>在大家之前的实验中，我们使用的是同步 RAM 接口，它具有一个很简单的时序：当拍发送地址，下一拍就能返回数据。然而，并不是所有设备都能保证同步 RAM 接口的时序要求：也许从发起请求到收到数据之间会间隔许多时钟周期，这样，数据的请求方就不能默认请求发出的下一拍时，返回的数据是有效的。另一方面，CPU 和其他设备很可能工作在不同的时钟频率下，因此它们的信号是异步的，需要使用接口进行同步。</p>
<p>因此，必须引入<strong>握手</strong>（handshaking）机制，使得数据的<strong>主方</strong>（请求方，master）和数据的<strong>从方</strong>（接收方，slave）能够按照正确的时序协作。同时，接口有利于工业界制定统一的标准，使得设备的扩展变得容易。</p>
<p>在实验中，我们所使用的类 SRAM 接口是自定义接口，之后的 AXI 接口则是工业标准。</p>
<h2 id="soc">SOC 结构</h2>
<p>SOC 描述了<strong>主从设备</strong>、<strong>转换桥</strong>及其<strong>互联关系</strong>，我们可以在 <code>mycpu_env/soc_verify/soc_hs_bram/soc_lite_top.v</code> 中找到它的原理图：</p>
<div class="highlight"><pre><span></span><code>     -------------------------
     |           cpu         |
     -------------------------
   inst|                  | data
       |                  | 
       |        ---------------------
       |        |    1 x 2 bridge   |
       |        ---------------------
       |             |            |           
       |             |            |           
-------------   -----------   -----------
| inst ram  |   | data ram|   | confreg |
-------------   -----------   -----------
</code></pre></div>
<p>在实验用的 SOC 中，CPU 是主设备，inst ram、data ram 和 confreg 是从设备，1 x 2 bridge 是转换桥。</p>
<p>CPU 对外暴露两个类 SRAM 接口，其中一个直接连接到同样具有类 SRAM 接口的 inst ram 上；另一个连接到一个 1 x 2 bridge 上，它的作用是将一个接口变成两个，从而可以连接两个设备：data ram 和 confreg。</p>
<h2 id="_2">控制外设</h2>
<p>先来看硬件部分。LoongArch 访问外设的方法是 <strong>MMIO</strong>，也就是将外设寄存器直接映射到地址空间上，CPU 通过 <code>ld/st</code> 指令进行操作。CPU 访问外设的数据通路是：</p>
<ul>
<li>流水线向数据类 SRAM 总线发起访存请求（CPU 内部逻辑）</li>
<li>访存请求到达 1 x 2 bridge 上，转换桥进行仲裁，将请求送到与 confreg 相连的总线上（<code>bridge_1x2.v</code>）</li>
<li>confreg 请求，内部进行处理，改变输出端口的电平（<code>confreg.v</code>）</li>
<li>通过约束文件将输出端口绑定到芯片引脚上，从而控制具体的外设（<code>soc_lite_top.xdc</code>）</li>
</ul>
<p>再来看软件部分。我们需要使用 <code>ld/st</code> 指令来操作外设，因此，需要知道<strong>访问的地址</strong>以及<strong>读写数据的含义</strong>。在运行的功能测试程序中，我们已经使用了 LED、数码管以及拨码开关这 3 种外设。通过阅读功能测试的代码，可以了解控制它们的方式，而这些控制程序就是它们的<strong>驱动程序</strong>。</p>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p>外设分为<strong>可探测</strong>和<strong>不可探测</strong>两种，我们所使用的外设<strong>全部为不可探测</strong>外设。因此，需要进行<em>软硬件协同</em>，驱动程序开发者需要知道 SOC 设计时为外设分配的地址空间。</p>
</div>
<h3 id="_3">直接读写外设</h3>
<p>以下外设直接通过读写对应的地址映射的寄存器来控制：</p>
<table>
<thead>
<tr>
<th align="center">外设名称</th>
<th align="center">地址</th>
<th align="center">宽度</th>
<th align="center">读写属性</th>
<th align="center">读值</th>
<th align="center">写值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">双色 LED</td>
<td align="center"><code>0xbfaf_f030</code><br><code>0xbfaf_f040</code></td>
<td align="center">32 bit</td>
<td align="center">W</td>
<td align="center">-</td>
<td align="center"><code>0x0</code> 熄灭<br><code>0x1</code> 绿色<br><code>0x2</code> 红色</td>
</tr>
<tr>
<td align="center">单色 LED</td>
<td align="center"><code>0xbfaf_f020</code></td>
<td align="center">32 bit</td>
<td align="center">W</td>
<td align="center">-</td>
<td align="center">末 16 位每比特对应一个 LED，<code>0x1</code> 为灭，<code>0x0</code> 为亮</td>
</tr>
<tr>
<td align="center">数码管</td>
<td align="center"><code>0xbfaf_f050</code></td>
<td align="center">32 bit</td>
<td align="center">W</td>
<td align="center">-</td>
<td align="center">32 位每 4 位对应 1 个数码管显示的值</td>
</tr>
<tr>
<td align="center">拨码开关</td>
<td align="center"><code>0xbfaf_f060</code></td>
<td align="center">32 bit</td>
<td align="center">R</td>
<td align="center">末 8 位每比特对应一个开关，拨上为 <code>0x0</code>，拨下为 <code>0x1</code></td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">矩阵键盘</td>
<td align="center"><code>0xbfaf_f070</code></td>
<td align="center">32 bit</td>
<td align="center">R</td>
<td align="center">末 16 位每比特对应一个按键，松开为 <code>0x0</code>，按下为 <code>0x1</code></td>
<td align="center">-</td>
</tr>
</tbody>
</table>
<p>说明：</p>
<ul>
<li>双色 LED 有两个地址，低地址对应 FPGA 板上右侧的 LED ，高地址对应左侧 LED 。</li>
<li>
<p>矩阵键盘末 16 位与键盘位置对应关系为：</p>
<div class="highlight"><pre><span></span><code>+----+----+----+----+
|  0 |  1 |  2 |  3 |
+----+----+----+----+
|  4 |  5 |  6 |  7 |
+----+----+----+----+
|  8 |  9 | 10 | 11 |
+----+----+----+----+
| 12 | 13 | 14 | 15 |
+----+----+----+----+
</code></pre></div>
</li>
</ul>
<div class="admonition info">
<p class="admonition-title">信息</p>
<p>在 confreg 的实现中，拨码开关的复位值被显示到单色 LED 上，有兴趣的同学可以参看 <code>confreg.v</code> 了解它是怎么实现的。</p>
</div>
<h3 id="_4">外部计数器</h3>
<p>confreg 中实现了一个<strong>恒定频率计数器</strong>为整个 SOC 提供计时功能。具体而言，confreg 模块具有两个时钟输入 clk 和 timer_clk，其中 clk 用于 confreg 中寄存器的驱动，timer_clk 则用于计数器的驱动，使其每个周期自动加一。在我们使用的 SOC 中，timer_clk 的频率是 100MHz，通过查看时钟 IP 核 clk_pll 的配置可以明确这一点：</p>
<p><img alt="" src="../img/pll.png" /></p>
<p>在 confreg 中，计数器是一个 RW 类型的寄存器，我们可以写入一个值对它进行设置，也可以读出当前的值，它的地址为 <code>0xbfaf_e000</code>。</p>
<p>通过这个计数器，软件可以实现 <code>delay()</code> 和 <code>sleep()</code> 等带有定时功能的函数。</p>
<h3 id="_5">扩展其他外设</h3>
<p>在目前的 SOC 中，使用的是类 SRAM 总线接口。前面提到，它是一种自定义接口，因此扩展起来有一些麻烦：我们需要自己编写满足类 SRAM 接口的外设控制器以及转换桥。而后续使用的 AXI 接口则是一种工业接口，在 Vivado 中可以很方便地调用许多具有 AXI 接口的外设控制器以及转换桥（一般采用交叉总线 cross bar 的形式，简称 xbar），并且 Vivado 提供了 Block Design 功能方便我们进行 SOC 设计。</p>
<p>简单来说，添加不可探测的外设需要以下几个步骤：</p>
<ol>
<li>编写 RTL 或调用 IP 核得到外设控制器</li>
<li>手动为外设控制器分配地址空间，将其通过转换桥接入 SOC</li>
<li>根据分配的地址，编写对应的驱动程序，实现自定义功能</li>
</ol>
<h2 id="_6">裸机程序</h2>
<p>裸机程序运行时没有操作系统，更得不到库函数的支持。编写裸机程序是为了更好地理解软硬件是如何协同工作的。</p>
<h3 id="_7">第一入口：汇编语言</h3>
<p>LoongArch32r 架构的复位 PC 为 <code>0x1c00_0000</code>，计算机复位后立即从该地址取指令，因此我们编写的裸机程序入口也在这里。之所以要使用汇编语言，是因为计算机复位时只有有限的资源状态是确定的，不足以运行 C 语言程序，我们需要使用汇编指令为运行 C 语言程序做好充足的准备。</p>
<p>首先我们需要明确在计算机复位后有哪些资源状态是确定的，以及运行 C 语言程序需要哪些资源。</p>
<ul>
<li>
<p>复位后确定状态的资源：   </p>
<ul>
<li>通用寄存器：<code>$r0 = 0x0</code>，<code>$pc = 0x1c00_0000</code></li>
<li>特权寄存器：<ul>
<li><code>CRMD</code>：<code>PLV = 0x0</code>，<code>IE = 0x0</code>，<code>DA = 0x1</code>，<code>PG = 0x0</code>，<code>DATF = 0x0</code>，<code>DATM = 0x0</code></li>
<li><code>ECFG</code>：<code>LIE = 0x0</code></li>
<li><code>ESTAT</code>：<code>IS[1:0] = 0x0</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>运行 C 语言需要的资源：</p>
<ul>
<li>通用寄存器：<code>$sp</code> 需要指向一段可用的内存作为栈</li>
<li>内存：将 bss 段初始化为 <code>0x0</code></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p>由于目前 CPU 还不支持虚拟内存管理，其他内容无需由我们设置。CPU 复位后默认处于“直接地址翻译模式”，我们仅保持在该模式下即可驱动外设，并运行一些程序。</p>
<p>SOC 中的指令、数据 RAM 大小均为 1MB，都映射到地址段 <code>0x1c00_0000 ~ 0x1c0f_ffff</code>。我们在逻辑上将它们视为一个，装载相同的二进制文件，只要没有自修改代码，程序便能正常运行。</p>
</div>
<h3 id="c">第二入口：C 语言</h3>
<p>准备好 C 语言环境后，就可以从汇编语言跳转到 C 语言执行了：</p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># start.S</span>
<span class="kc">...</span>
<span class="n">bl</span> <span class="n">main</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">// main.c</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></p>
<p>之后我们便可以使用 C 语言操作这些外设了，如果你还不清楚什么 C 语言如何对应到 <code>ld/st</code> 指令，请复习《计算机体系结构基础》。</p>
<h3 id="_8">链接脚本</h3>
<p>为了能够自定义程序的布局，我们需要编写一个链接脚本：</p>
<div class="highlight"><pre><span></span><code>/* bare-metal.ld */
SECTIONS
{
    . = 0x1c000000;             /* 指定起始地址 */
    .text : {                   /* 所有 text 段紧跟其后 */
        *(.text)
    }
    .rodata : {                 /* 所有 rodata 段在 text 段后面 */
        *(.rodata)
    }
    .data : {                   /* 所有 data 段在 rodata 段后面 */
        *(.data)
    }

    __bss_start = .;            /* 定义一个标号指向 bss 的开始位置 */
    .bss : { *(.bss) }          /* 所有 bss 段在 rodata 段后面 */
    __bss_end = .;              /* 定义一个标号指向 bss 的结束位置 */

    . = ALIGN(0x1000);          /* 要求下一个标号开始的位置对齐到 0x1000 (4KB) */
    bootstack = .;              /* 定义一个标号指向栈底 */
    bootstacktop = . + 0x1000;  /* 定义一个标号指向栈顶 */
}
</code></pre></div>
<p>有了链接脚本，我们可以直接在汇编或 C 语言中使用定义的标号，比如将栈顶存储到寄存器 <code>$sp</code>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># start.S</span>
<span class="kc">...</span>
<span class="n">la</span>      <span class="o">$</span><span class="n">sp</span><span class="p">,</span> <span class="n">bootstacktop</span>
</code></pre></div>
<h3 id="coe">二进制文件与 COE 文件</h3>
<p>为了将程序直接加载到 FPGA 上的 RAM 中，我们需要将程序转化为 Vivado 能识别的 <code>.coe</code> 文件，其中包含了一些描述头和载入 RAM 的二进制内容，我们可以使用课程环境下的 <code>convert</code> 工具将二进制文件转化为 COE 文件。</p>
<p>整体的转换流程如下：</p>
<div class="highlight"><pre><span></span><code>  start.S   gcc              objcopy           convert
  main.c   -----&gt;  main.elf  -----&gt;  main.bin  -----&gt;  inst_ram.coe
(source code)     (elf file)       (binary file)        (coe file)
</code></pre></div>
<p>我们可以编写一个 Makefile 将整个流程连接起来：</p>
<div class="highlight"><pre><span></span><code><span class="c"># Makefile</span>
<span class="nv">CROSSTOOL</span><span class="o">:=</span>loongarch32r-linux-gnusf-
<span class="nv">CC</span>       <span class="o">:=</span><span class="k">$(</span>CROSSTOOL<span class="k">)</span>gcc
<span class="nv">OBJCOPY</span>  <span class="o">:=</span><span class="k">$(</span>CROSSTOOL<span class="k">)</span>objcopy
<span class="nv">OBJDUMP</span>  <span class="o">:=</span><span class="k">$(</span>CROSSTOOL<span class="k">)</span>objdump

<span class="nf">.PHONY</span><span class="o">:</span> <span class="n">clean</span>

<span class="nf">all</span><span class="o">:</span> <span class="n">inst_ram</span>.<span class="n">coe</span> <span class="n">inst_ram</span>.<span class="n">mif</span>

<span class="nf">main.elf</span><span class="o">:</span> <span class="n">start</span>.<span class="n">S</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">bare</span>-<span class="n">metal</span>.<span class="n">ld</span>
    <span class="k">$(</span>CC<span class="k">)</span> -nostdlib -T bare-metal.ld start.S main.c -O0 -o <span class="nv">$@</span>

<span class="nf">main.bin</span><span class="o">:</span> <span class="n">main</span>.<span class="n">elf</span>
    <span class="k">$(</span>OBJCOPY<span class="k">)</span> -O binary main.elf main.bin

<span class="nf">inst_ram.coe inst_ram.mif</span><span class="o">:</span> <span class="n">main</span>.<span class="n">bin</span> <span class="n">convert</span>
    ./convert

<span class="nf">convert</span><span class="o">:</span> <span class="n">convert</span>.<span class="n">c</span>
    gcc ./convert.c -o convert

<span class="nf">test.S</span><span class="o">:</span> <span class="n">main</span>.<span class="n">elf</span>
    <span class="k">$(</span>OBJDUMP<span class="k">)</span> -d main.elf &gt; <span class="nv">$@</span>

<span class="nf">clean</span><span class="o">:</span>
    rm -rf main.elf main.bin test.S inst_ram.coe inst_ram.mif rom.vlog convert
</code></pre></div>
<p>在使用 gcc 编译程序时，使用了一个特殊的选项 <code>-nostdlib</code>，顾名思义，该选项的含义是不使用标准库。这是因为对于裸机程序而言，没有操作系统的支持，我们是无法使用标准库的。</p>
<h3 id="_9">上板测试</h3>
<ol>
<li>打开工程，使用上面产生的 <code>inst_ram.coe</code> 来 recustomize inst_ram。</li>
<li>使用上面产生的 <code>inst_ram.coe</code> 来 recustomize data_ram。</li>
<li>生成比特流，烧入到实验箱中，观察结果。</li>
</ol>
<div class="admonition info">
<p class="admonition-title">信息</p>
<p>由于目前我们使用的是类 SRAM 总线，SOC 为“<a href="https://en.wikipedia.org/wiki/Harvard_architecture">哈佛结构</a>”，<code>inst_ram</code> 和 <code>data_ram</code> 分开，因此需要将 ELF 文件中的代码段加载到 <code>inst_ram</code> 中，将数据段加载到 <code>data_ram</code> 中。因为目前的 COE 文件同时提取了 ELF 文件的代码段和数据段，所以我们只需要将 COE 文件同时加载到两个 RAM 中即可。</p>
<p>切换到 AXI 总线后，SOC 就变成了“<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">冯·诺依曼结构</a>”，<code>inst_ram</code> 和 <code>data_ram</code> 合为了一个 <code>axi_ram</code>，因此只需要将 COE 文件加载到这个 RAM 中即可。</p>
</div>
<div class="admonition question">
<p class="admonition-title">练习</p>
<ol>
<li>编写一个裸机程序，实现 16 个单色 LED 的跑马灯功能。要求：16个单色 LED 从右到左依次点亮，每个灯点亮 1s 后立刻切换到下一个灯。</li>
<li>
<p>编写一个裸机程序，实现斐波那契数列的求和功能。要求：</p>
<ol>
<li>用拨码开关的复位值控制求和的项数，拨上为 1，拨下为 0，记拨码开关的值为 <code>n</code>。求第 0 项到第 <code>n</code> 项的和。</li>
<li>将求和结果以 16 进制的形式输出到数码管上。</li>
<li>（选做）利用拨码开关和矩阵键盘实现多次不同输入的求和计算。调整拨码开关的值，程序等待按下某个自定义的矩阵键盘按键（类比输入“回车”），得到输入，计算结果。</li>
</ol>
</li>
</ol>
</div>
<h2 id="_10">参考资料</h2>
<ul>
<li><a href="https://osdocs.cqu.ai/">重庆大学操作系统实验文档</a></li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../lec01/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Lec 01 - “龙芯杯”大赛介绍" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Lec 01 - “龙芯杯”大赛介绍
            </div>
          </div>
        </a>
      
      
        
        <a href="../misc/linux/" class="md-footer__link md-footer__link--next" aria-label="Next: Linux 操作系统杂谈" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Linux 操作系统杂谈
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.8492ddcf.min.js"></script>
      
    
  </body>
</html>